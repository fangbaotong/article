<html><head><meta http-equiv='Content-Type' content='text/html; charset=UTF-8'><title>作为一个php程序员们必须知道的PHP代码优化的40条建议</title>
<style>
body{
	width:960px;
	margin:0 auto;
}
#title{
	text-align:center;
}
</style>
</head><body><div id='title'><h2>作为一个php程序员们必须知道的PHP代码优化的40条建议</h2></div><span>作为一个<span id="rlt_5"><span id="rlt_10">php</span></span>程序员们必须知道的PHP代码优化的40条建议：</span><span> .n1&amp;Jsey </span> <br />
<span><span>1.如果一个方法可静态化，就对它做静态声明。速率可提升至4倍。</span></span><span> Cyd/HTNh&lt; </span> <br />
<span><span>2.echo 比 print 快。</span></span><span> QK?V^E </span> <br />
<span><span>3.使用echo的多重参数(译注：指用逗号而不是句点)代替字符串连接。</span></span><span> &gt;zqaV@T </span> <br />
<span><span>4.在执行for循环之前确定最大循环数，不要每循环一次都计算最大值。</span></span><span> 'x{oAtCP9 </span> <br />
<span><span>5.注销那些不用的变量尤其是大数组，以便释放内存。</span></span><span> d_d&amp;su E </span> <br />
<span><span>6.尽量避免使用__get，__set，__autoload。</span></span><span> P4q5#r </span> <br />
<span><span>7.require_once()代价昂贵。</span></span><span> jhm/&lt;= </span> <br />
<span><span>8.在包含文件时使用完整路径，<span id="rlt_15">解析</span><span id="rlt_12">操作</span><span id="rlt_11">系统</span>路径所需的时间会更少。</span></span><span>O_8	SlW0e </span> <br />
<span><span>9.如果你想知道脚本开始执行(译注：即<span id="rlt_1"><span id="rlt_2"><span id="rlt_7">服务</span></span>器</span>端收到客户端请求)的时刻，使用$_SERVER['REQUEST_TIME']要好于time()。</span></span><span> ,eBC]4)B6 </span> <br />
<span><span>10.函数代替正则表达式完成相同功能。</span></span><span> k7Bh[	..! </span> <br />
<span><span>11.str_replace函数比preg_replace函数快，但strtr函数的效率是str_replace函数的四倍。</span></span><span> _i	{Y0d+ </span> <br />
<span><span>12.如果一个字符串替换函数，可接受数组或字符作为参数，并且参数长度不太长，那么可以考虑额外写一段替换代码，使得每次传递参数是一个字符，而不是只写一行代码接受数组作为查询和替换的参数。</span></span><span> f~T7?D0u}N </span> <br />
<span><span>13.使用选择分支语句(译注：即switch case)好于使用多个if，else if语句。</span></span><span> GZ~Tl0U </span> <br />
<span><span>14.用@屏蔽<span id="rlt_4"><span id="rlt_9">错误</span></span>消息的做法非常低效。</span></span><span> .p! DVQ"a </span> <br />
<span><span>15.打开apache的mod_deflate模块。</span></span><span> uVUU1@ </span> <br />
<span><span>16.数据库连接当使用完毕时应关掉。</span></span><span> ;.uYWP|9 </span> <br />
<span><span>17.$row['id']的效率是$row[id]的7倍。</span></span><span> 3/`BK{ </span> <br />
<span><span>18.错误消息代价昂贵。</span></span><span> RFL* qd4 </span> <br />
<span><span>19.尽量不要在for循环中使用函数，比如for ($x=0; $x &lt; count($array); $x)每循环一次都会调用count()函数。</span></span><span> UsyNn39 </span> <br />
<span><span>20.在方法中递增局部变量，速度是最快的。几乎与在函数中调用局部变量的速度相当。</span></span><span> \1!Q.V </span> <br />
<span><span>21.递增一个全局变量要比递增一个局部变量慢2倍。</span></span><span> D+3?p </span> <br />
<span><span>22.递增一个对象属性(如：$this-&gt;prop++)要比递增一个局部变量慢3倍。</span></span><span> 20V~?xs~ </span> <br />
<span><span>23.递增一个未预定义的局部变量要比递增一个预定义的局部变量慢9至10倍。</span></span><span> `f;w </span> <br />
<span><span>24.仅定义一个局部变量而没在函数中调用它，同样会减慢速度(其程度相当于递增一个局部变量)。PHP大概会检查看是否存在全局变量。</span></span><span> OP1`!P	y </span> <br />
<span><span>25.方法调用看来与类中定义的方法的数量无关，因为我(在测试方法之前和之后都)添加了10个方法，但性能上没有变化。</span></span><span> M	YF ^zheD </span> <br />
<span><span>26.派生类中的方法运行起来要快于在基类中定义的同样的方法。</span></span><span> Uw("+[5O0 </span> <br />
<span><span>27.调用带有一个参数的空函数，其花费的时间相当于执行7至8次的局部变量递增操作。类似的方法调用所花费的时间接近于15次的局部变量递增操作。</span></span><span> d &lt;}'eBT' </span> <br />
<span><span>28.用单引号代替双引号来包含字符串，这样做会更快一些。因为PHP会在双引号包围的字符串中搜寻变量，单引号则不会。当然，只有当你不需要在字符串中包含变量时才可以这么做。</span></span><span> ;stuTj@vH </span> <br />
<span><span>29.输出多个字符串时，用逗号代替句点来分隔字符串，速度更快。注意：只有echo能这么做，它是一种可以把多个字符串当作参数的"函数"(译注：PHP手册中说echo是语言结构，不是真正的函数，故把函数加上了双引号)。</span></span><span> 3[[oAp </span> <br />
<span><span>30.Apache解析一个PHP脚本的时间要比解析一个静态HTML页面慢2至10倍。尽量多用静态HTML页面，少用脚本。</span></span><span> _/LGGt4&amp;% </span> <br />
<span><span>31.除非脚本可以缓存，否则每次调用时都会重新编译一次。引入一套PHP缓存机制通常可以提升25%至100%的性能，以免除编译开销。</span></span><span> 5`.CzQVb </span> <br />
<span><span>32.尽量做缓存，可使用memcached。memcached是一款高性能的内存对象缓存系统，可用来加速动态Web应用程序，减轻<span id="rlt_3"><span id="rlt_8"><span id="rlt_13">数据</span>库</span></span>负载。对运算码 (OP code)的缓存很有用，使得脚本不必为每个请求做重新编译。</span></span><span> Z6zV	9hn </span> <br />
<span><span>33.当操作字符串并需要检验其长度是否满足某种要求时，你想当然地会使用strlen()函数。此函数执行起来相当快，因为它不做任何计算，只返回在zval结构(C的内置数据结构，用于存储PHP变量)中存储的已知字符串长度。但是，由于strlen()是函数，多多少少会有些慢，因为函数调用会经过诸多步骤，如字母小写化(译注：指函数名小写化，PHP不区分函数名大小写)、哈希查找，会跟随被调用的函数一起执行。在某些情况下，你可以使用isset()技巧加速执行你的代码。</span></span><span> @wcF#?J </span> <br />
<span><span>(举例如下)</span></span><span> ,,{;G'R| </span> <br />
<span><span>if (strlen($foo) &lt; 5) { echo "Foo is too short"; }</span></span><span> J#..xJ?XRD </span> <br />
<span><span>(与下面的技巧做比较)</span></span><span> @GN2v,WA? </span> <br />
<span><span>if (!isset($foo{5})) { echo "Foo is too short"; }</span></span><span> tVRN3fJH </span> <br />
<span><span>调用isset()恰巧比strlen()快，因为与后者不同的是，isset()作为一种语言结构，意味着它的执行不需要函数查找和字母小写化。也就是说，实际上在检验字符串长度的顶层代码中你没有花太多开销。</span></span><span> @PvO;]]% </span> <br />
<span><span>34.当执行变量$i的递增或递减时，$i++会比++$i慢一些。这种差异是PHP特有的，并不适用于其他语言，所以请不要<span id="rlt_14">修改</span>你的C或Java代码并指望它们能立即变快，没用的。++$i更快是因为它只需要3条指令(opcodes)，$i++则需要4条指令。后置递增实际上会产生一个临时变量，这个临时变量随后被递增。而前置递增直接在原值上递增。这是最优化处理的一种，正如Zend的PHP优化器所作的那样。牢记这个优化处理不失为一个好主意，因为并不是所有的指令优化器都会做同样的优化处理，并且存在大量没有装配指令优化器的互联网服务提供商(ISPs)和<span id="rlt_6">服务器</span>。</span></span><span> L~6%Fi&amp;n4 </span> <br />
<span><span>35.并不是事必面向对象(OOP)，面向对象往往开销很大，每个方法和对象调用都会消耗很多内存。</span></span><span> )$n%4 : </span> <br />
<span><span>36.并非要用类实现所有的数据结构，数组也很有用。</span></span><span> '0D$C},^|8 </span> <br />
<span><span>37.不要把方法细分得过多，仔细想想你真正打算重用的是哪些代码?</span></span><span> I_&lt;VGUk </span> <br />
<span><span>38.当你需要时，你总能把代码分解成方法。</span></span><span> 5*%Gh&amp;) </span> <br />
<span><span>39.尽量采用大量的PHP内置函数。</span></span><span> bp?5GU&amp;Uy </span> <br />
<span><span>40.如果在代码中存在大量耗时的函数，你可以考虑用C扩展的方式实现它们。</span></span></body></html>